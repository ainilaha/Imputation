---
title: "Cobalt Paper"
date: "Updated on : `r date()`"
output: html_document
---
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 0. Goal

The goal of this vignette is to replicate the analysis presented in ``Association of blood cobalt concentrations with dyslipidemia, hypertension, and diabetes in a US population
A cross-sectional study; Hongxin Wang, MD, Feng Li, MD, Jianghua Xue, MD, Yanshuang Li, MD, Jiyu Li, MD''

 The authors report using data for the years 2015 to 2018 which cover two of the two-year reporting epochs in NHANES.
The Questionnaires we want will have the suffixes _I and _J. 

## 1. Load libs

```{r setup,warning=FALSE,message=FALSE}
library(splines)
library(ggplot2)
library(ggpubr)
library(dplyr)
#library(nhanesA)
library(phonto)
library(EnWAS)
library(knitr)
library(mice)

library(naniar)
library(visdat)
library(corrplot)
```


## 2. Data and Preprocessiing
#### 2.1) Blood Pressure Data

 In the next code segment we show how to obtain blood pressure measurements from NHANES tables.  We have already ascertained that these measurements are contained in Questionnaires that are named BPX_I and BPX_J and that there were replicate measurements taken.  Both systolic (BPXS) and diastolic (BPXD) measurements were taken
on each occassion.  We will use the average of these two measurements.
```{r data_blood,warning=FALSE,message=FALSE}
bptablenames = nhanesSearchTableNames('BPX[_]')
bptablenames |> kable()
```
We can see that blood pressure data was collected for other years as well, but for now we will just extract the data for the 2015-2016 and 2017-2018 years. We combine these into a single dataframe.

```{r extract_data, warning=FALSE, message=FALSE}
blood_df <- unionQuery(c("BPX_I", "BPX_J"), cols =c("BPXDI1","BPXDI2","BPXSY1","BPXSY2"))
dim(blood_df)
# Average the the first and second reads
# taking some care to keep one measurement if the other is missing
blood_df$DIASTOLIC <- rowMeans(blood_df[, c("BPXDI1", "BPXDI2")], na.rm=TRUE)
blood_df$DIASTOLIC[is.na(blood_df$BPXDI1) & is.na(blood_df$BPXDI2)] = NA
blood_df$SYSTOLIC <- rowMeans(blood_df[, c("BPXSY1", "BPXSY2")], na.rm=TRUE)
blood_df$SYSTOLIC[is.na(blood_df$BPXSY1) & is.na(blood_df$BPXSY2)] = NA
dim(blood_df)
blood_df[1:10,] |> kable()
```
  In our analysis we can then look at the average of the measurements across the two different time points as a way to
better estimate the actual blood pressure for each participant.

#### 2.2 Loading the Demographic, Body Measures, and Cholesterol data into R

The authors state: 
Participants with cobalt and lipid data were included (n = 6866). Demographic characteristics of the participants, including age, gender, body mass index (BMI), education level, race, family poverty-income ratio and smoking status, were collected. Clinical data, such as blood pressure, total cholesterol (TC), low-density lipoprotein cholesterol (LDL-C), HDL-C, triglycerides (TGs), hypertension, diabetes and history of medication use, including antihypertensive drugs, hypoglycemic drugs, and lipid-lowering drugs, were extracted.

In the code below, we start with the variable names, which we had obtained by searching based on the variable descriptions (not shown) and restrict by the years that the authors had chosen.  We will avoid looking at the LDL measurements and triglycerides as they were done on a subset of the participants, and we want to make sure we are as inclusive as possible.

```{r demo_body,warning=FALSE,message=FALSE}

##get the appropriate table names for the variables we will need
##BP
BPTabs = nhanesSearchVarName("BPQ050A", ystart="2015", ystop="2018")
LDLTabs = nhanesSearchVarName('LBDLDL',ystart="2015", ystop="2018")
##BPQ050A - currently taking meds for hypertension
##BPQ080 - told by Dr. you have high cholesterol
##BPQ100D - now taking meds for high cholesterol
##A1C
A1C = nhanesSearchVarName("LBXGH",ystart="2015", ystop="2018")
##been told by Dr. has diabetes
DrDiab = nhanesSearchVarName("DIQ010",ystart="2015", ystop="2018")
##DIQ050 - taking insulin now
##DIQ070 - taking pills for blood sugar

##HDLTabs
HDLTabs = nhanesSearchVarName("LBDHDD",ystart="2015", ystop="2018")
BMITabs = nhanesSearchVarName("BMXBMI", ystart="2015", ystop="2018")
BMXTabs = nhanesSearchVarName("BMXBMI",ystart="2015", ystop="2018")
DIQTabs = nhanesSearchVarName("DIQ010",ystart="2015", ystop="2018")
COBTabs = nhanesSearchVarName("LBXBCO",ystart="2015", ystop="2018" )
TotChol = nhanesSearchVarName("LBXTC",ystart="2015", ystop="2018" )

cols = list(DEMO_I=c("RIDAGEYR","RIAGENDR","RIDRETH1","DMDEDUC2","years"), 
            DEMO_J=c("RIDAGEYR","RIAGENDR","RIDRETH1","DMDEDUC2","years"),
            BPQ_I=c('BPQ050A','BPQ020','BPQ080','BPQ100D'),
            BPQ_J=c('BPQ050A','BPQ020','BPQ080','BPQ100D'), 
            HDL_I=c("LBDHDD"),HDL_J=c("LBDHDD"),
            GHB_I="LBXGH",GHB_J="LBXGH",
            DIQ_I=c("DIQ010","DIQ050","DIQ070","DIQ160"),
            DIQ_J=c("DIQ010","DIQ050","DIQ070","DIQ160"), 
            BMX_I="BMXBMI", BMX_J="BMXBMI",
            TCHOL_I="LBXTC", TCHOL_J="LBXTC"
            )
var2Table = cols[c(1,3,5,7,9,11,13)]
base_df <- jointQuery(cols)
dim(base_df)

```
##FIXUP some vars
```{r}
cholMeds = base_df$BPQ100D
cholMeds[base_df$BPQ080==2] = 2
cholMeds = factor(cholMeds,levels=c("1","2"), labels=c("Yes","No"))
table(cholMeds,useNA="always")
base_df$cholMeds=cholMeds

##now fixup the oral meds for diabetes
##not counting insulin right now...might need it
dontskip = base_df$DIQ010 == 1 | base_df$DIQ010 == 3 | base_df$DIQ160 == 1
hypoglycemicMeds = base_df$DIQ070
hypoglycemicMeds[!dontskip] = 2 #No
hypoglycemicMeds = factor(hypoglycemicMeds,levels=c(1,2,7,9), labels=c("Yes", "No",NA,NA))
table(hypoglycemicMeds,useNA="always")
base_df$hypoglycemicMeds = hypoglycemicMeds

```
##Smoking
In the code chunk below we extract the smoking data, and then try to create the groupings
used in the paper.  They have three groups, non-smokers, current smokers and ex-smokers. We use the `SMQ_I` and `SMQ_J` tables. We will define non-smoker as someone who as never smoked more than 100 cigarettes (`SMQ020`), anyone who has smoked more will be either
a current smoker or an ex-smoker (`SMQ040`)
```{r Smoking }
smokingTab= unionQuery(c("SMQ_I", "SMQ_J"),cols = c("SMQ020","SMQ040"))
tdf = merge(base_df, smokingTab, all.x=TRUE)  
tdf = tdf[tdf$RIDAGEYR>=40,]
nn = nhanesTranslate("SMQ_J", colnames=c("SMQ020","SMQ040"))
##have a look at the coding for SMQ020
nn[[1]]
##check to see what values are in the data
table(tdf$SMQ020, useNA="always")
##for SMQ040 too
table(tdf$SMQ040, useNA="always")
smokingVar = ifelse(tdf$SMQ020==2, "Non-smoker", ifelse(tdf$SMQ040==3, "Ex-smoker",
                    "Smoker"))
table(smokingVar, useNA="always")
##from the paper n=6866, Ex=1950,Non=3744,Current=1165
```
#Glucose
```{r Glucose, warning=FALSE, message=FALSE}
##fasting glucose
Fastgluc = nhanesSearchVarName("LBXGLU", ystart="2015", ystop="2018")
glucTab = unionQuery(c("GLU_I", "GLU_J"), cols="LBXGLU")
base_df = merge(base_df, glucTab, all.x=TRUE)
```
The two variables that require additional lab work are LDLs and cobalt levels. As a result they were done on a much smaller set of people.  So instead of loading them simultaneously we extract them below and then use the `merge`
```{r load TRIGLY and CRCO}
ldlTab = unionQuery(c("TRIGLY_I","TRIGLY_J"), cols=c("LBXTR","LBDLDL")) 
dim(ldlTab)
cobaltTab = unionQuery(c("CRCO_I", "CRCO_J"), cols= "LBXBCO")
dim(cobaltTab)
var2Table = c(var2Table, list("TRIGLY_I"=c("LBXTR","LBDLDL"), CRCO_I="LBXBCO"))
##we merge keeping as many records as we can, the all.x argument is important
bdf = merge(base_df, ldlTab, all.x=TRUE)
base_df = merge(bdf, cobaltTab, all.x=TRUE)
dim(base_df)
```
If we were to remove all records with missing values at this point we would be left with a very small number of cases.  So we will try to be careful not to loose too many data points.
### 2.3)  merge and PHESANT-like process

Now you have a dataframe with the data, but you will need to better understand the variables, exposures and responses.  To help with that we have created some tools, based on related work in the UK Biobank called PHESANT  (cite PHESANT)).  The process takes each variable (column)
and reports what type of data it is, continuous or multi-level (ie factors). We report the number of levels, you can use the `nhanesTranslate` function to learn more about the levels of the factor. Some numeric quantities are reported such as the ratio of unique values to the length of vector, the proportion of zeros, and the proportion of missing values. NHANES has chosen to store categorical data types (ordered or unordered) as integers. For example, education level, `DMDEDUC2` is identified as `Multilevel-8 `.  You can learn more about the details of the NHANES data in the Quick Start Vignette (cite quick start).

```{r data,warning=FALSE,message=FALSE}

data <- merge(base_df, blood_df, all.x=TRUE,by="SEQN")
##fix up our list linking variable names to the table they came from
var2Table = c(var2Table, list("BPX_I"=c("BPXDI1","BPXDI2","BPXSY1","BPXSY2")))
phs_dat = phesant(data)
data = phs_dat$data
DT::datatable(phs_dat$phs_res)

```

In the next code chunk we will convert the multilevel variables into R factors. To do this we make use of the nhanesTranslate function. While that function does most of the work, there are some variables we need to deal with manually to replicate the analysis. First, the years variable is something we added, so we need to deal with it manually.  Then we use `nhanesTranslate` to transform all of the internal values.  Then we need to do a little more work on modifying levels of the education variable.  The authors decided to group education into three levels, less than high school (<HS), high school (HS), and more than school-school(>HS).  We also need to address some issues around the hypertension variables.
Particpants were asked (BPQ020) whether they had ever been told by a doctor or health care professional that they had high blood pressure.  The survey was designed to then skip over a number of questions about their hypertension if they said they did not have hypertension. However this then introduces missing values in the question BPQ050A, which was whether or not they were currently taking a prescription for hypertension. Presumably only people who had been told by their doctor they have hypertension would be taking a perscription and we will need to manually adjust the data so that these are answered No, rather than missing.

In the next code chunk we modify the data accordingly, drop out everyone who is under 40 and remove any individuals that have missing data in any row.

```{r}
##years is something we have added so we need to translate it directly
data$years <- as.factor(data$years)
##almost surely not the most efficient way
for(tabname in names(var2Table)) {
  data = nhanesTranslate(tabname, var2Table[[tabname]], data)
}
levsED = levels(data$DMDEDUC2)
##examine them and then put into groupings <HS, HS and > HS
levels(data$DMDEDUC2) <- c(">HS","HS",">HS","<HS","<HS","DK","R")
levels(data$DMDEDUC2) <- c(">HS", "HS", "<HS",NA, NA)
##
#the variables BPQ050A and BPQ040A are taken conditionally so they have missing values put in
# for anyone who answered no to BPQ020 - and we need to fix that - since there answer to 50A 
 # had they been asked, would have been no (one presumes)
 #set up a dummy for the ones we want to change - also turn "Don't know" from BPQ020 into NA
  gg = is.na(data$BPQ050A) & data$BPQ020=="No"
  bpq50A = data$BPQ050A
  bpq50A[gg] = "No"
 #check it worked
 # table(bpq50A, data$BPQ050A, useNA="always")
  
# The current study included 6866 US adults aged 40 years or older. 
data$BPQ050A = bpq50A
##remove any record with at least one NA and then subset to those over 40
##data <- na.omit(data)
data <- data[data$RIDAGEYR>=40,]
dim(data)

```
At this point we have `r nrow(data)` individuals left. 

## Replication of Table 1
Table 1 provides some basic summaries of the demographic data. We will create a 
temporary subset of the data that uses only the complete cases.

```{r, message=FALSE, warning=FALSE}
pcobalt = ifelse(data$LBXBCO <= 0.12, "<=0.12", 
                ifelse(data$LBXBCO >= 0.13 & data$LBXBCO <= 0.14, "0.13-0.14",
                  ifelse(data$LBXBCO >= 0.15 & data$LBXBCO <= 0.18, "0.15-0.18",
                         ifelse(data$LBXBCO >= 0.19, ">=1.9",
                         NA)  )))
##make it an ordered factor 
pcob = factor(pcobalt, levels=c("<=0.12","0.13-0.14", "0.15-0.18",">=1.9"), ordered=TRUE)
data$pcobalt = pcob
table(pcob, useNA="always")
AgeGp = data |> group_by(pcobalt) |> summarise(mean=mean(RIDAGEYR,na.rm=TRUE),SD=sd(RIDAGEYR,na.rm=TRUE))

```

## 2.4 Definitions
Here we implement the definitions from Section 3.1 of the Cobalt paper. For hypertension they described using reported systolic and diastolic blood pressure measurements as well as self-reported statements regarding whether a physician had ever told them that they have high blood pressure.  

Note that it is unclear whether the authors used averaged over 2 measurements for the systolic and diastolic blood pressure measurements. Still, we use average them because it would give us more accurate blood pressure measurements.

One might also look at the use of prescribed hypertensives, as these will modulate the systolic and diastolic measures.  Data on self-report come from the BPQ tables in NHANES.
https://wwwn.cdc.gov/nchs/nhanes/2011-2012/BPQ_G.htm

```{r RiskFactors,warning=FALSE,message=FALSE}
# "Hypertension was defined as systolic blood pressure (SBP) ≥140 mm Hg, diastolic blood pressure ≥90mm Hg, or the use of antihypertensive medication. "
data$hypertension <- data$DIASTOLIC >= 90 | data$SYSTOLIC >= 140 |  data$BPQ050A=="Yes"
barplot(table(data$hypertension))
```
```{r Diabetes, warning=FALSE, message=FALSE}
data$diabetes = data$DIQ010 == "Yes" | data$LBXGLU > 110 | data$LBXGH > 6.5
barplot(table(data$diabetes))

data$HighLDL = data$LBDLDL > 130
barplot(table(data$HighLDL))
 
data$LowHDL = (data$RIAGENDR=="Male" & data$LBDHDD < 40) |    (data$RIAGENDR=="Female" & data$LBDHDD < 50) 
barplot(table(data$LowHDL))

```
Now lets define the elevated total cholesterol variable.

```{r Dyslipidemia}
elevatedTC = data$LBXTC>200
data$elevatedTC = elevatedTC
```

Note that some of our groupings are very similar to those reported in the Cobalt paper, but some, notably Elevated LDLs are quite different. This discrepency should be explored (it may have to do with incorrect subsetting by age).
## 2.5 Compare with Table-2
```{r, message=FALSE,warning=FALSE}

DBP = data |> group_by(pcobalt) |> summarise(mean=mean(DIASTOLIC, na.rm=TRUE),SD=sd(DIASTOLIC,na.rm=TRUE))
DBP$stat = paste(round(DBP$mean,1),"±",round(DBP$SD,1))
DBPmn = mean(data$DIASTOLIC, na.rm=TRUE)
DBPsd = sd(data$DIASTOLIC, na.rm=TRUE)

SBP = data |> group_by(pcobalt) |> summarise(mean=mean(SYSTOLIC,na.rm=TRUE),SD=sd(SYSTOLIC, na.rm=TRUE))
SBP$stat = paste(round(SBP$mean,1),"±",round(SBP$SD,1))
SBPmn = mean(data$SYSTOLIC, na.rm=TRUE)
SBPsd = sd(data$SYSTOLIC, na.rm=TRUE)

dbp_t = t(DBP)
colnames(dbp_t) = DBP$pcobalt

sbp_t = t(SBP)
colnames(sbp_t) = SBP$pcobalt

table2 = rbind(sbp_t["stat",],dbp_t["stat",])
table2 = table2[,c("<=0.12","0.13-0.14","0.15-0.18",">=1.9")]
table2 = cbind("Blood Pressures"=c("SBP (mm Hg), mean±SD","DBP (mm Hg), mean±SD"),table2)
```
It shows the number we have is not exactly the same as the one in the table-2 in the paper. The authors did not use the average of two reads of the blood pressure measurements.

```{r, message=FALSE,warning=FALSE}
library(kableExtra)
kbl(table2) |>
  kable_classic() |>
  add_header_above(c(" " = 1, "Cobalt Quartiles (ug/L)" = 4))
```



## Missing pattern across variables (eg. age)

The plot below displays the missingness pattern across the age variable (RIDAGEYR). For instance, the columns "Now taking prescribed medicine(BPQ100D)" and "Ever told have health risk for diabetes (DIQ170)" demonstrate that the younger the age, the more missing data. This can be attributed to the fact that young individuals are less likely to take medication and have a lower risk for diabetes.


```{r, missing_age}
gg_miss_fct(data,fct = RIDAGEYR)
```

## Plot missing pattern
The following plot displays the missingness pattern of all columns in the dataframe. It is evident that BPQ100D, LBXGLU, LBXTR, LBDLDL, diabetes, and HighLDL have more than 40% of missing data, making it difficult to impute accurately.

```{r miss_clipp,warning=FALSE}
vis_miss(data,warn_large_data=FALSE)
```

## Missing Correlation

Showing the correlation of data missingness is crucial as it provides an indication of which variables to choose for imputing missing data. The higher the correlation of missingness, the more likely they are to be missing at the same time. For instance, LBDHDD and LBXTC have a high correlation of missingness, implying that they are missing together in many records. Therefore, it may not be a good idea to use one as a variable to impute another.

```{r}

missing_cols = sapply(data, function(x)sum(is.na(x)))
missing_cols = missing_cols[missing_cols>0] # select the data with missing values

correlation = cor(is.na(data[,names(missing_cols)]))
corrplot(correlation, type = "upper", order = "hclust",
         tl.col = "black", tl.srt = 45)
```



#### Imputing Data with MICE
In the following code, we use Classification and Regression Tree (CART) base on MICE, with 1 time inpuation with 5 iteration.  The we can save the imputed data into variable `impt_data`.

```{r mice,warning=FALSE}
imp =  mice(data[,2:ncol(data)], method='cart',m=1,maxit=5) # exclude SEQN
impt_data = mice::complete(imp,action=1) # imputed data

```


## 3.Regression Models

In Section 3.2 of the Cobalt paper the authors describe their use of binary logistic regression models.  They use dyslipidemia as the outcome and adjust for age, sex and BMI (their model 1).  They split cobalt levels into the groupings described above and then fit logistic models that were linear in the covariates.  Here we provide the tools to replicate that analysis and also explore the use of regression splines to fit the continuous variables in the model, namely age, BMI and cobalt levels.

In the following section, we run the logistic regression models as generalized linear models (GLMs). In the models, the outcome of the hypertension indicator and the adjusted variables are age (RIDAGEYR), gender (RIAGENDR), BMI (BMXBMI), educationm(DMDEDUC2), and ethnicity (RIDRETH1). The first GLM is with linear terms, and the second GLM also adds terms linearly together but applies a natural spline to the continuous variables.      

```{r Model1, warnings=FALSE, message=FALSE}
subSet = data[, c("hypertension","RIDAGEYR", "RIAGENDR", "BMXBMI","DMDEDUC2", "RIDRETH1")]

lm_logit <- glm(hypertension ~ RIDAGEYR + RIAGENDR + BMXBMI+DMDEDUC2+RIDRETH1, data = subSet, family = "binomial",na.action=na.omit)


subSetImpt = impt_data[, c("hypertension","RIDAGEYR", "RIAGENDR", "BMXBMI","DMDEDUC2", "RIDRETH1")]
# subSetImpt = na.omit(subSetImpt)

lm_logit_impt <- glm(hypertension ~ RIDAGEYR + RIAGENDR + BMXBMI+DMDEDUC2+RIDRETH1, data = subSetImpt, family = "binomial",na.action=na.omit)

```

### 3.1) QA/QC
```{r}
sjPlot::tab_model(lm_logit,lm_logit_impt,
                  dv.labels = c("Raw (Hypertension)", "Imputed (Hypertension)"),
                  show.ci = FALSE,show.stat = TRUE,show.se = TRUE,p.style = "scientific", digits.p = 2)

```
