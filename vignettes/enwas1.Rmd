---
title: "Environment-Wide Association Study (EnWAS)"
date: "Updated on : `r date()`"
output: html_document
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 0. Pepare for EnWAS

Details can check the previous vignette page.

```{r setup,warning=FALSE,message=FALSE}
library(EnWAS)
library(splines)
library(ggplot2)
library(ggpubr)
library(dplyr)
# data("nhanes")
# data("exposure_vars")
# phesant_res <- phesant(nhanes)
# nhanes <- phesant_res$data

library(DBI)
nhanes_db <- DBI::dbConnect(RSQLite::SQLite(), "../nhanes.sqlite")


base_df <- dbGetQuery(nhanes_db, "SELECT demo.SEQN,
                                    (BPXDI1+BPXDI2)/2 AS DIASTOLIC,
                                    RIAGENDR,RIDAGEYR,RIDRETH1,BMXBMI, INDFMPIR
                                  FROM
                                    DemographicVariablesAndSampleWeights as demo
                                  INNER JOIN BodyMeasures ON demo.SEQN=BodyMeasures.SEQN
                                  INNER JOIN BloodPressure ON demo.SEQN=BloodPressure.SEQN
                                  WHERE
                                      RIDAGEYR>20
                                    AND BMXBMI is not NULL
                                    AND BPXDI1 IS NOT NULL and BPXDI1 <> 0
                                    AND BPXDI2 IS NOT NULL and BPXDI2 <> 0
                                    AND INDFMPIR IS NOT NULL  
                       ")
base_df$RIDRETH1 <- as.factor(base_df$RIDRETH1)
base_df$RIAGENDR <- as.factor(base_df$RIAGENDR)

years <- dbGetQuery(nhanes_db, "SELECT SEQN, years from demo")

base_df <- merge(base_df,years, by="SEQN")
base_df$years <- as.factor(base_df$years)

```

## 1. Run EnWAS

### 1.0 Base Model

```{r enwas, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
ns_str <-
  'DIASTOLIC ~ ns(RIDAGEYR, knots = seq(30, 80, by = 10), Boundary.knots=c(20,90)) * RIAGENDR + ns(BMXBMI,knots = c(seq(15, 45, by = 5),seq(45,65,by=10)),Boundary.knots=c(10,75)) + RIDRETH1'

```
### 1.1 Data Preprocess with PHESANT-like tool before EnWAS
Before feeding the data into any model, we probably need to do data preprocess (e.g., clean or fill NAs, drop out columns, and transformation). In the data preprocessing phase, it is essential to properly tidy the data that models can process and learn from the data distributions; as said, “garbage in, garbage out.”  In other words, the outputs of the models may be meaningless if we feed the raw data without tidiness and with too much noise or too little information.

However, it requires a lot of effort to preprocess the data when we have large data sets with thousands of phenotype to check.
For NHANES data, we developed a PHESANT-like tool that can preprocess the data, and it can help convert the data into suitable data types. 

***We may need to discuss how we allow users to configure the tables and prototypes, json file seems OK.***


The following function takes data for the base model merge with the phenotype data configured JSON file and queries from the base. Further, we can  EnWAS function to run EnWAS on the phenotypes.
```{r enwas00, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
enwas_all <- function(base_df=base_df, nhanes_db=nhanes_db,
                      epx_file="./phenotypes.json",trans="none"){
  exposures <- jsonlite::fromJSON(epx_file)
  qc_mtrx <- data.frame(matrix(ncol = 9, nrow = 0))
  xwas_df <- data.frame(matrix(ncol = 9, nrow = 0))
  model_list <- list() ## need to replace with :vector(mode = "list", length = num_var)
  for(tb_name in names(exposures)){
    exprs <- exposures[tb_name][[1]]
    expr_data <- load_exprs(exprs,tb_name,nhanes_db)
    data <- merge(base_df,expr_data$data,by="SEQN")
    ns_enwas <- enwas(ns_str, exprs, data,trans = trans)
    xwas_df <- rbind(xwas_df,ns_enwas$enwas_res)
    qc_mtrx <- rbind(qc_mtrx,ns_enwas$qc_mtx)
    model_list <- c(model_list,ns_enwas$model_list)
  }
  return (list(qc_mtx = qc_mtrx,enwas_res = xwas_df,model_list=model_list))
}

xwas <- enwas_all(base_df,nhanes_db)
```

The following forest plot shows the estimates and CI of the exposure variables and only displays the top 30 ranked by absolute values of the estimates. The variables with their CI containing zeros are also removed.

```{r enwas00_forest, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
forest_plot(xwas$enwas_res,30) # filter out CI contains 0
```




### 3. Inverse Normal Transformation

In addition, the EnWAS model can use inverse normal transformation on the wide association variables, which would be helpful to improve the models' performance when the distributions are skewed.

$$
\operatorname{INT}\left(W_{i}\right)=\Phi^{-1}\left\{\frac{\operatorname{rank}\left(W_{i}\right)-c}{n+1-2 c}\right\}, c \in[0,1 / 2]
$$ where c=3/8 is recommended.

The following forest plot shows the top 30 exposures, ranked and filtered as abovementioned.
```{r enwas_inv, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
xwas_inv <- enwas_all(base_df,nhanes_db,trans = "inv")
forest_plot(xwas_inv$enwas_res,30)
```

### 4. Log and Z-transformation

The phenotype are transformed with log and z-standardized.

The following forest plot shows the top 30 exposures, ranked and filtered as abovementioned.
```{r enwas_inv1, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
xwas_log <- enwas_all(base_df,nhanes_db,trans = "log")
forest_plot(xwas_log$enwas_res,30)
```



The following forest plot shows the top 20 exposures, ranked by the differences in the estimates for the same variables.
- `ns` denotes the variables non-transformed, but the estimates  with beta^hat * SD(X)
- `ns_inv` denotes variables transformed inverse normal transformation
- `ns-log` denotes variables transformed with log followed by z-transformation

```{r enwas_inv1log, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
forest_plot_mult(
  list(
    ns = xwas$enwas_res,
    ns_inv = xwas_inv$enwas_res,
    ns_log = xwas_log$enwas_res
  ),20
)
```

The following scatter plot shows the inverse normal transformation estimates against estimates (beta^hat * SD(X)) of nontransformed variables. The top 20 has added text for the variables, but it is pretty clear to show the information.

```{r enwas_inv22, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
enwas_res = data.frame(x=xwas$enwas_res$estimate,
                       x_upper = xwas$enwas_res$upper,
                       x_lower = xwas$enwas_res$lower,
                       y=xwas_inv$enwas_res$estimate,
                       y_upper=xwas_inv$enwas_res$upper,
                       y_lower=xwas_inv$enwas_res$lower,
                       z=xwas_log$enwas_res$estimate,
                       z_upper=xwas_log$enwas_res$upper,
                       z_lower=xwas_log$enwas_res$lower,
                       diff1 = abs(xwas_inv$enwas_res$estimate-xwas$enwas_res$estimate),
                       diff2 = abs(xwas_log$enwas_res$estimate-xwas$enwas_res$estimate),
                       diff3 = abs(xwas_log$enwas_res$estimate-xwas_inv$enwas_res$estimate),
                       term = xwas_inv$enwas_res$term
                       )

library(ggrepel)

top_n_diff <- 20

enwas_res |>
ggplot(aes(x,y,label = term, colour=term)) +
  geom_point(size=1.5)+
  geom_errorbar(aes(ymin = y_lower, ymax = y_upper))+
  geom_errorbarh(aes(xmin = x_lower,xmax = x_upper)) +
  geom_text_repel(data=dplyr::top_n(enwas_res,top_n_diff,diff1),aes(label=term))+
  theme_minimal()+
  theme(legend.position = "none")+xlab("EnWAS") + ylab("EnWAS INT")
```

The following scatter plot remove the error bars and text labeled the top 20 most difference variables.

Scatter plot for estimates of EnWAS  non-transformed (`EnWAS`) with inverse normal transformation (`EnWAS INT`).
```{r enwas_inv230, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
enwas_res |>
ggplot(aes(x,y,label = term,colour=term)) +
  geom_point(size=1.5)+
  geom_smooth(aes(x,y,colour=NULL),method = "lm", formula = y~x)+
  geom_text_repel(data=dplyr::top_n(enwas_res,top_n_diff,diff1),aes(label=term))+
  theme_minimal()+
  theme(legend.position = "none")+xlab("EnWAS") + ylab("EnWAS INT")
```

Scatter plot for estimates of EnWAS  non-transformed (`EnWAS`) with log and z-transformation (`EnWAS Log`).

```{r enwas_inv231, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
enwas_res |>
ggplot(aes(x,z,label = term,colour=term)) +
  geom_point(size=1.5)+
  geom_smooth(aes(x,z,colour=NULL),method = "lm", formula = y~x)+
  geom_text_repel(data=dplyr::top_n(enwas_res,top_n_diff,diff1),aes(label=term))+
  theme_minimal()+
  theme(legend.position = "none")+xlab("EnWAS") + ylab("EnWAS Log")
```

Scatter plot for estimates of EnWAS inverse normal transformation (`EnWAS INT`) with log and z-transformation (`EnWAS Log`).

```{r enwas_inv232, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
enwas_res |>
ggplot(aes(y,z,label = term,colour=term)) +
  geom_point(size=1.5)+
  geom_smooth(aes(y,z,colour=NULL),method = "lm", formula = y~x)+
  geom_text_repel(data=dplyr::top_n(enwas_res,top_n_diff,diff3),aes(label=term))+
  theme_minimal()+
  theme(legend.position = "none")+xlab("EnWAS INT") + ylab("EnWAS Log")

```


### 3.1 Likelihood Ratio Test: Inverse Normal Transformation to None transformd

It is still very clear to me to do the Likelihood Ratio Test because they are not nested; therefore, ANOVA LRT does not apply here. On the other hand, the vuongtest `nonnest2::vuongtest(,nested=FALSE)` produces very strange LRstat. 


```{r enwas_inv2, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
library(knitr)
library(kableExtra)

terms <- xwas$enwas_res$term
lrt_mtx <- matrix(0, nrow = length(terms), ncol = 3)
colnames(lrt_mtx) <- c("term","LRTstat","P_value")
lrt_mtx[,1] <- terms

for (i in 1:length(terms)){
  term <- terms[i]
  non_trans_model <- xwas$model_list[term][[1]]
  inv_model <- xwas_inv$model_list[term][[1]]
  vong <- nonnest2::vuongtest(non_trans_model,inv_model,nested = TRUE)
  lrt_mtx[i,2] <- round(vong$LRTstat,3)
  lrt_mtx[i,3] <- round(vong$p_LRT$A,4)
}

lrt_mtx <- as.data.frame(lrt_mtx)

lrt_mtx |> dplyr::arrange(P_value) |> head(10) |>
  kbl() |> kable_classic_2(full_width = F)

```



### 1.0  Folate - RBC
Folate, serum
'LBDRFO', # RBC folate (ng/mL)
'LBDRFOSI' # RBC folate (nmol/L)
[cook book](https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/FOLATE_J.htm)

```{r enwas44, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
# fs_exprs = c('LBDRFO', # RBC folate (ng/mL)
#              'LBDRFOSI' # RBC folate (nmol/L)
#           )
# 
# FolateRBC_expr <- load_exprs(fs_exprs,"FolateRBC",nhanes_db)
# data <- merge(base_df,FolateRBC_expr$data,by="SEQN")
# # LBDRFOSI behave very strange without inverse nomral transformation
# ns_enwas_FolateRBC_expr <- enwas(ns_str, fs_exprs, data,inv_norm = TRUE)

```





### 4. P-Value or FDR

```{r p_vales, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
plot_p(list(ns = xwas$enwas_res,  ns_inv = xwas_inv$enwas_res))
```

### 5. QA/QC

```{r aic, echo=TRUE,warning=F, message=FALSE,out.width = '90%',dpi = 200}


xwas$enwas_res |> filter(lower*upper > 0) |>
    dplyr::top_n(30,abs(estimate)) |>
   dplyr::arrange(dplyr::desc(estimate)) |> 
  kbl() |> kable_classic_2(full_width = F)

xwas_inv$enwas_res |> filter(lower*upper > 0) |>
    dplyr::top_n(30,abs(estimate)) |>
   dplyr::arrange(dplyr::desc(estimate)) |> 
  kbl() |> kable_classic_2(full_width = F)







```

### 6. AC/QC plots

```{r lrt, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
# lollipop(qc_mtx,y="Deviance")
# lollipop(qc_mtx,y="Ratio") + ylab("Ratio(%)")
# lollipop(qc_mtx,y="LR")
# lollipop(qc_mtx,y="p_LRT",is_desc = TRUE)
# lollipop(qc_mtx,y="BIC",is_desc = TRUE)
# lollipop(qc_mtx,y="AIC",is_desc = TRUE)
```


### 7. Cross Validation for EnWAS

```{r cv, echo=TRUE,warning=F, out.width = '90%',dpi = 200}

cross_val <- function(model_str,data_set,top_exrs,trans=FALSE,label="DIASTOLIC"){
  
  # years <- levels(data_set$years)
  years <- c("2003-2004","2005-2006","2007-2008","2009-2010")
  len_year <- length(years)
  mse_mtx <- matrix(0, nrow = length(top_exrs), ncol = len_year)
  rownames(mse_mtx) <- top_exrs
  colnames(mse_mtx) <- years

  for (i in 1:len_year){
      cv_train <- data_set[data_set$years != years[i], ]
      cv_test <- data_set[data_set$years == years[i], ]
      if (nrow(cv_test)>1){
        mse <- enwas_cv(model_str,top_exrs,train_set = cv_train,
                        test_set = cv_test,lab_col = label,
                        inv_norm =trans)
        mse_mtx[,i] <- mse 
      }

  }
 mse_df <- as.data.frame(reshape2::melt(mse_mtx))
 colnames(mse_df) <- c("Exposures","Years","MSE")
 mse_df

}





top_n_exprs <- xwas$enwas_res |> filter(lower*upper > 0) |>
    dplyr::top_n(30,abs(estimate)) |>
   dplyr::arrange(dplyr::desc(estimate)) 
top_n_exprs$term



exposures <- jsonlite::fromJSON("./phenotypes.json")
cv_df <- data.frame(matrix(ncol = 3, nrow = 0))
for(tb_name in names(exposures)){
  exprs <- exposures[tb_name][[1]]
  exprs <- intersect(top_n_exprs$term,exprs)
  if(length(exprs)>0){
    expr_data <- load_exprs(exprs,tb_name,nhanes_db)
    data <- merge(base_df,expr_data$data,by="SEQN")
    cv_tmp <- cross_val(ns_str,data,exprs)
    cv_df <- rbind(cv_df,cv_tmp)
  }
  
}


cv_df |>
  ggplot(aes(x=Exposures,y=MSE,fill=Exposures )) +
  geom_boxplot()+
  scale_x_discrete(guide = guide_axis(angle = 45))+
  theme_minimal()+theme(legend.position="none")


dbDisconnect(nhanes_db)

```
