---
title: "Quick Start"
author: "Laha Ale, Christopher Endres, Robert Gentleman"
output: html_document
# output: rmarkdown::html_vignette
# vignette: >
  # %\VignetteIndexEntry{Phonto Quick Start}
  # %\VignetteEngine{knitr::rmarkdown}
  # %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(phonto)
library(DT)
```
### Introduction
  The NHANES data set provides a large diverse set of data to study health and other sociological and epidemiological topics.  It is used very widely and the bulk of the data are publicly available.  Our goal with the Epiconductor project is to enable users access to the data using a container that contains a SQL database and R together with other software to support different analyses of the data.  We believe that this will increase the speed of access and provide a platform for reproducibility.  This document outlines some of the ways you can interact with the NHANES data while using the container.

### NHANES 

The [National Health and Nutrition Examination Survey (NHANES)](https://www.cdc.gov/nchs/nhanes/index.htm) datasets are collected from the Centers for Disease Control and Prevention in the USA, including demographics, dietary, laboratory, examination, and questionnaire data. The five publicly available data categories are: - Demographics (DEMO) - Dietary (DIET) - Examination (EXAM) - Laboratory (LAB) - Questionnaire (Q). The abbreviated forms in parentheses may be substituted for the long form in nhanesA commands. There is also limited access data, eg. genetics, that requires written justification and prior approval before users are granted access. We restrict our tools to the publicly available data.

The survey is carried out in two year "epochs" from 1999-2000. Within each epoch, a set of people are surveyed, however not all of the participants are surveyed across all of the components. Within each of the data categories NHANES has organized the data into Questionnaires and provides web interfaces for descriptions of the contents of each questionnaire.  We do not replicate the web interface as users can browse that information using standard tools, but we have constructed an integrated SQL database representation of much of the publicly available NHANES data.  Placing all of the data into a single database facilitates searching and extraction of relevant values, and this provide many advantages to the individual researcher, as well as the research world at large.

Each NHANES participant is assigned a unique ID that is stored in the database as <tt>SEQN</tt>. This is used as the primary key and merging of data extracted from different tables should be based on this variable (<tt>SEQN</tt>). 
For each two-year epoch, NHANES provides a set of data, documentation and code books, organized by each of the five publicly available categories mentioned above.  Users can explore the available data a high level, by searching within epoch, category, and measure. One example is the [Body Measures](https://wwwn.cdc.gov/nchs/nhanes/2001-2002/BMX_B.htm) table which provides data from the 2001-2002 examination data. The web page provides details on the measurements and how they are recorded.
Here are two examples:
![SEQN](seqn.png){width=80%}
![weight](weight.png){width=80%}


There are many ways to access and utilize the NHANES data. Users familiar with SQL can connect and explore the data with database client tools such as HeidiSQL and DataGrip, or other programming languages. 

<FONT COLOR="RED"> README(TJFS): Not sure how/why this fits in here: </FONT>
*In the [example](https://github.com/ccb-hms/NHANES/blob/main/Code/R/regressionExample.R), we show, using R, how one can connect to the database and perform a simple sample analysis. In addition, we also wrapped some functions for users to get access to the data easily, the function can be see in [phonto package](https://github.com/ccb-hms/phonto/tree/main/vignettes).*


Others may utilize [web-based tools](https://www.cdc.gov/nchs/nhanes/index.htm) provided by the CDC for investigating the data and metadata. In addition there are two existing R packages called [nhanesA](https://cran.r-project.org/web/packages/nhanesA/index.html) (Endres) and [RNHANES](https://cran.r-project.org/web/packages/RNHANES/index.html) (Susman). While most of the data collected can easily be downloaded from the CDC website, accessing the data in that way can be problematic and error prone. The [nhanesA](https://cran.r-project.org/web/packages/nhanesA/index.html) package provides a set of tools to search and download the NHANES data and metadata, making the data more accessible to user. However, one drawback is that the tool must access the NHANES website every time the user calls the R function, which leads slow getting of the data and raises errors occasionally due to network issues.

In the spirit of producing more easily reproduced and shared analyses we have created a SQL database in a Docker (cite Docker) container that contains most of the currently available NHANES data. Around that SQL database we have constructed a number of R packages and other tools that help scientists analyze the data. Since all of the code and data are under version control, anyone can obtain the same version of the data and code and produce identical results.  

### 1. Searching the NHANES database

Comprehensive lists of NHANES variables are maintained for each data group. For example, the demographics variables are available at https://wwwn.cdc.gov/nchs/nhanes/search/variablelist.aspx?Component=Demographics. The `nhanesSearch` function allows the investigator to input search terms, match against the comprehensive variable descriptions, and retrieve the list of matching variables.

<FONT COLOR="RED">README(TJFS): This function would be much more useful if it could search AND and not just OR </FONT>

  
#### 1.1  nhanesSearch()
This function will list all the tables
   <FONT COLOR="RED"> README(TJFS): arguments are required for this to run, will search all tables.(i.e. cannot run nhanesTables() and get all tables) would be good if empty arguments would produce all available tables (like nhanesSearch()). Would be great to be able to search across multiple years (i.e. specify a start and stop year nhanesSearch())
  
   </FONT>
 
#### 1.1 nhanesSearchTableNames

This function lets users search for tables in the database by the table name, which can be either the short names used by NHANES or the 
longer descriptive names.  For our Dockerized container no restricted data can be accessed (ie the RDC tables are excluded) and the `includerdc` option is not supported.

 <FONT COLOR="RED"> FIXME: is this correct Laha? If so can you add something to the man page to show this and an example of using
the long descriptive names - also the man page says: includerdc: If TRUE then RDC only tables are included (default=FALSE).
but what is an RDC table? can you explain on the man page? nhanesSearchTableNames(): can search the tables by the name patterns, and it returns a data frame of the results, which contains the questionnaire (the table names provided in NHANES websites), a longer descriptive table name (eg.BloodPressure) and the survey years. </FONT>

 <FONT COLOR="blue">No, it does not support search the long tale name, it was designed for search short table names as the nhanesA package does. But I can added it if that is what we want.</FONT>


For example, we can search blood pressure related table by the following code. We choose "BPX" as the parameters based the CDC table name conventions. The users can pass more sophistic search patterns according "LIKE string" in sql Server, more details can be found [here](https://learn.microsoft.com/en-us/sql/t-sql/language-elements/like-transact-sql?view=sql-server-ver16).
```{r}
res = nhanesSearchTableNames("BPX", details=TRUE)
datatable(res)
```
In the research data frame, Questionnaire present CDC tables, and TableName present long descriptive names which hold the data across the years.


In the code chunk below we exploit the fact that the data are stored in a SQLServer database. We can provide access to some of the special functions within that database for matching strings. In the example below the string "BPX[_]" string is passed to the database engine directly.  This string matches only tables containing the string "BPX_"; therefore, the table named "BPXO_J" will not match the search string. We note that the table named "BPX" also has no underscore and it also will not match. Readers familiar with regular expressions may want to explore on-line documentation for SQL Server that helps them identify ways of creating more specialized search expressions.
```{r}
res = nhanesSearchTableNames("BPX[_]", details=TRUE)
datatable(res)
```

# 1.2 Searching for Variables
 One of the main challenges in using the NHANES data set is finding the tables that contain 
 the data you want to analyze.  In this section we outline some of the basic methods you can use to do the searching. In the next code chunk are a variety of different ways you can use the search functionality.
 The returned value can be put into a searchable data table that you can use to further filter, sort and search for specific variables.
```{r}
# nhanesSearch use examples
#
# Search on the word bladder, restrict to the 2001-2008 surveys, 
# print out 50 characters of the variable description
bl = nhanesSearch("bladder", ystart=2001, ystop=2008, nchar=50)
dim(bl)
#
# Search on "urin" (will match urine, urinary, etc), from 1999-2010, return table names only
urin = nhanesSearch("urin", ignore.case=TRUE, ystop=2010, namesonly=TRUE)
dim(urin)
#
# Search on "urin", exclude "during", search surveys from 1999-2010, return table names only
urinsm = nhanesSearch("urin", exclude_terms="during", ignore.case=TRUE, ystop=2010, namesonly=TRUE)
dim(urinsm)
#
# Restrict search to 'EXAM' and 'LAB' data groups. Explicitly list matching and exclude terms, leave ignore.case set to default value of FALSE. Search surveys from 2009 to present.
urinrest = nhanesSearch(c("urin", "Urin"), exclude_terms=c("During", "eaten during", "do during"), data_group=c('EXAM', 'LAB'), ystart=2009)
dim(urinrest)
#
# Search on "tooth" or "teeth", all years
teeth = nhanesSearch(c("tooth", "teeth"), ignore.case=TRUE)
dim(teeth)
#
# Search for variables where the variable description begins with "Tooth"
sttooth = nhanesSearch("^Tooth")
dim(sttooth)
datatable(sttooth)
```
 
Now suppose we wanted to find variables that had LDL (low density lipoproteins).  To do that we can use the nhanesSearch function. In the code below 
```{r}
s1 = nhanesSearch("LDL")
LDLTabs = nhanesSearchVarName('LBDLDL')
```
 
 
# 2. unionQuery()

The unionQuery() function is designed to aggregate data across the years. Tt aggregate the researched results and returns the results as a data frame. For example, the blood pressure tables in CDC are BPX, BPX_B,...BPX_J from years 1999-2000 to 2017-2018. The users can aggregate some or all of the data.

```{r search_union,warning=FALSE,message=FALSE}
tablenames = nhanesSearchTableNames('BPX[_]')
blood_df <- unionQuery(tablenames,cols =c("BPXDI1","BPXDI2","BPXSY1","BPXSY2"))
DT::datatable(blood_df[1:400,])
```

## 3. jointQuery()
The jointQuery() function, table list of table name and a set of column names, it merges the researched results and returns the results as a data frame. The data are joined using SEQN which is the unique identifier for individuals.
#FIXME: ok this one is more interesting - but you need to perhaps explain that SEQN is the primary key in this database and that jointQuery is going to merge on that quantity.  And this might be where you want to be clear that SEQNs are unique to epochs - they don't appear in more than one, and even if it was the same person there is no way to know that.

The example below is a much more complex, but also more realistic query example. In this example we are collecting data across 4 tables, DEMO, BPQ, HDL and TRIGLY. And also across two of the data collection epochs (I and J).  We first construct our query string, note that it is important that every table appears twice, once with an _I and once with an _J. In addition the variables being selected must be the same for each epoch and each table.

```{r}
cols = list(DEMO_I=c("RIDAGEYR","RIAGENDR","RIDRETH1","DMDEDUC2","years"),
                     DEMO_J=c("RIDAGEYR","RIAGENDR","RIDRETH1","DMDEDUC2","years"),
                     BPQ_I=c('BPQ050A','BPQ020'),BPQ_J=c('BPQ050A','BPQ020'),
                     HDL_I=c("LBDHDD"),HDL_J=c("LBDHDD"), TRIGLY_I=c("LBXTR","LBDLDL"),
            TRIGLY_J=c("LBXTR","LBDLDL"))
data <- jointQuery(cols)
tdata = data[1:100,]
datatable(tdata)
```


### 4. PHESANT-like process

The NHANES project provides thousands of phenotypes and exposures. Navigating these can be very challenging and we are in the process of developing tools that will aid users in navigating the data quickly and reliably. Developing tools that can better help analysts navigate data at this scale is important.  We are patterning our efforts on those that were developed for the UK Biobank (Bycroft et al. 2018) and specifically the PHESANT (Millard et al. 2017) package.  

We can run a PHESANT-like process to convert each column into data types. It also provides the ratio of unique values (`r_unique`), the proportion of zeros (`r_zeros`), and the ratio of NAs (`r_NAs`), which is calculated by the number of unique values, zeros, and NAs divided by total records. The categorical data types (ordered or unordered) are represented by integers, and we categorize them as multilevel. For example, education (DMDEDUC2) is labeled as Multilevel(7) which means it has 7 levels. Information on whether or not the levels are ordered would have to be obtain from the on-line NHANES documentation.

```{r}
phs_dat = phesant(data)
data = phs_dat$data
DT::datatable(phs_dat$phs_res)
categoricalVars = rownames(phs_dat$phs_res)[grep("^Multilevel", phs_dat$phs_res$types)]
categoricalVars
```

### 5.Setup factor levels for categorical variables

In the raw NHANES data stored in the database all categorical variables are represented as integers.  In order to make use of these for analysis you will need to transform them into factors in R.  

Categorical variables are presented with integers as shown below.

```{r}
data[,c('RIAGENDR', 'RIDRETH1','DMDEDUC2')] |> head() |> knitr::kable()
```
And the real factor levels for year 2003-2004 can be found in [the cookbook]() as shown below.
![gender](gender.png)
![enthinicity](ethinicity.png)
![education](edu.png)



The real factor levels can be set with nhanesTranslate() function.

```{r,DT.warn.size=FALSE}
##now we can translate the variables that need to be translated
t1 = nhanesTranslate("DEMO_J",c("RIDAGEYR","RIAGENDR","RIDRETH1","DMDEDUC2","years"),data=data)
datatable(t1[1:100,c('SEQN','RIDAGEYR','RIAGENDR', 'RIDRETH1')] )
```

##FIXME: Laha - somewhere you should have an explicit definition of what is in the code - what makes something continuous - what makesit discrete, what makes it ordered? In the first pass, all the categorical values are discrete integers - that does not make them ordered - you have to look at the actual levels - and we need to explain how our users will do that.


##FIXME - the more I think about it, we should only report a factor, if the column has been transformed into an R factor, and then you can get from that whether it is ordered or unordered.  When you get a column with integer values only (and less than whatever the PHESANT cut-off is, then call them "categorical" - let's reserve the label "factor" for R factors.

Currently, we are doing as the following flow chat, but both the ordered and unordered are considered as multilevel.
![PHESANT flow chat](phesant_like.png){width=80%}

